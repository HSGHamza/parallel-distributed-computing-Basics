# Chapter 5

## concurrent_futures_pooling

### Explaination:
This code compares the performance of sequential execution, thread pool execution, and process pool execution using the `concurrent.futures` module. It defines a `count` function, which performs a CPU-intensive operation (an empty loop) for each item in a list, and an `evaluate` function that calls `count` and prints the result. First, the tasks are executed sequentially by iterating through the list. Next, a `ThreadPoolExecutor` is used to run the tasks concurrently in multiple threads, and a `ProcessPoolExecutor` is employed to run them in multiple processes. The execution time for each method is measured and printed, highlighting the speed differences between sequential, threaded, and multiprocessing approaches.

### Output:
![Ergonomic](images/chair.png "Ergonomic ")


## concurrent_futures_pooling

### Explaination:
This code compares the performance of sequential execution, thread pool execution, and process pool execution using the `concurrent.futures` module. It defines a `count` function, which performs a CPU-intensive operation (an empty loop) for each item in a list, and an `evaluate` function that calls `count` and prints the result. First, the tasks are executed sequentially by iterating through the list. Next, a `ThreadPoolExecutor` is used to run the tasks concurrently in multiple threads, and a `ProcessPoolExecutor` is employed to run them in multiple processes. The execution time for each method is measured and printed, highlighting the speed differences between sequential, threaded, and multiprocessing approaches.

### Output:
![Ergonomic](images/chair.png "Ergonomic ")

## concurrent_futures_pooling

### Explaination:
This code compares the performance of sequential execution, thread pool execution, and process pool execution using the `concurrent.futures` module. It defines a `count` function, which performs a CPU-intensive operation (an empty loop) for each item in a list, and an `evaluate` function that calls `count` and prints the result. First, the tasks are executed sequentially by iterating through the list. Next, a `ThreadPoolExecutor` is used to run the tasks concurrently in multiple threads, and a `ProcessPoolExecutor` is employed to run them in multiple processes. The execution time for each method is measured and printed, highlighting the speed differences between sequential, threaded, and multiprocessing approaches.

### Output:
![Ergonomic](images/chair.png "Ergonomic ")


## concurrent_futures_pooling

### Explaination:
This code compares the performance of sequential execution, thread pool execution, and process pool execution using the `concurrent.futures` module. It defines a `count` function, which performs a CPU-intensive operation (an empty loop) for each item in a list, and an `evaluate` function that calls `count` and prints the result. First, the tasks are executed sequentially by iterating through the list. Next, a `ThreadPoolExecutor` is used to run the tasks concurrently in multiple threads, and a `ProcessPoolExecutor` is employed to run them in multiple processes. The execution time for each method is measured and printed, highlighting the speed differences between sequential, threaded, and multiprocessing approaches.

### Output:
![Ergonomic](images/chair.png "Ergonomic ")


## concurrent_futures_pooling

### Explaination:
This code compares the performance of sequential execution, thread pool execution, and process pool execution using the `concurrent.futures` module. It defines a `count` function, which performs a CPU-intensive operation (an empty loop) for each item in a list, and an `evaluate` function that calls `count` and prints the result. First, the tasks are executed sequentially by iterating through the list. Next, a `ThreadPoolExecutor` is used to run the tasks concurrently in multiple threads, and a `ProcessPoolExecutor` is employed to run them in multiple processes. The execution time for each method is measured and printed, highlighting the speed differences between sequential, threaded, and multiprocessing approaches.

### Output:
![Ergonomic](images/chair.png "Ergonomic ")


## concurrent_futures_pooling

### Explaination:
This code compares the performance of sequential execution, thread pool execution, and process pool execution using the `concurrent.futures` module. It defines a `count` function, which performs a CPU-intensive operation (an empty loop) for each item in a list, and an `evaluate` function that calls `count` and prints the result. First, the tasks are executed sequentially by iterating through the list. Next, a `ThreadPoolExecutor` is used to run the tasks concurrently in multiple threads, and a `ProcessPoolExecutor` is employed to run them in multiple processes. The execution time for each method is measured and printed, highlighting the speed differences between sequential, threaded, and multiprocessing approaches.

### Output:
![Ergonomic](images/chair.png "Ergonomic ")


## concurrent_futures_pooling

### Explaination:
This code compares the performance of sequential execution, thread pool execution, and process pool execution using the `concurrent.futures` module. It defines a `count` function, which performs a CPU-intensive operation (an empty loop) for each item in a list, and an `evaluate` function that calls `count` and prints the result. First, the tasks are executed sequentially by iterating through the list. Next, a `ThreadPoolExecutor` is used to run the tasks concurrently in multiple threads, and a `ProcessPoolExecutor` is employed to run them in multiple processes. The execution time for each method is measured and printed, highlighting the speed differences between sequential, threaded, and multiprocessing approaches.

### Output:
![Ergonomic](images/chair.png "Ergonomic ")
